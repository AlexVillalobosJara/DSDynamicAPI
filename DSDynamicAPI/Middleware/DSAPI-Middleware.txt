// =====================================================
// AuditMiddleware - NUEVO (para auditoría automática)
// =====================================================
using System.Diagnostics;
using System.Text.Json;

public class AuditMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<AuditMiddleware> _logger;

    public AuditMiddleware(RequestDelegate next, ILogger<AuditMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, IAuditService auditService)
    {
        var stopwatch = Stopwatch.StartNew();
        var requestContext = context.Items["RequestContext"] as RequestContext;

        if (requestContext?.IdAPI == null)
        {
            await _next(context);
            return;
        }

        var parametrosEnviados = ExtractParameters(context);
        var ambiente = requestContext.Environment;
        var direccionIP = requestContext.ClientIP;

        bool esExitoso = false;
        string? mensajeError = null;

        try
        {
            await _next(context);

            // Considerar exitoso si el status code es 2xx
            esExitoso = context.Response.StatusCode >= 200 && context.Response.StatusCode < 300;

            if (!esExitoso && context.Response.StatusCode != 404) // 404 se maneja aparte
            {
                mensajeError = $"HTTP {context.Response.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            esExitoso = false;
            mensajeError = ex.Message;
            throw; // Re-lanzar para que el ExceptionHandlingMiddleware lo maneje
        }
        finally
        {
            stopwatch.Stop();

            // Registrar auditoría de forma asíncrona
            _ = Task.Run(async () =>
            {
                try
                {
                    await auditService.LogAuditoriaAsync(
                        requestContext.IdAPI.Value,
                        requestContext.IdCredencial,
                        ambiente,
                        parametrosEnviados,
                        esExitoso,
                        mensajeError,
                        (int)stopwatch.ElapsedMilliseconds,
                        direccionIP);
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "Error registrando auditoría para API {IdAPI}", requestContext.IdAPI);
                }
            });
        }
    }

    private string? ExtractParameters(HttpContext context)
    {
        try
        {
            var parameters = new Dictionary<string, object>();

            // Query parameters
            foreach (var query in context.Request.Query)
            {
                if (query.Key != "idApi" && query.Key != "environment") // Excluir parámetros del sistema
                {
                    parameters[query.Key] = query.Value.ToString();
                }
            }

            // Form parameters (si es POST)
            if (context.Request.HasFormContentType && context.Request.Form.Any())
            {
                foreach (var form in context.Request.Form)
                {
                    parameters[form.Key] = form.Value.ToString();
                }
            }

            return parameters.Any() ? JsonSerializer.Serialize(parameters) : null;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Error extrayendo parámetros para auditoría");
            return null;
        }
    }
}﻿// =====================================================
// AuthenticationMiddleware - NUEVO (reemplaza TokenValidationMiddleware)
// =====================================================
using System.Net;
using System.Text.Json;

public class AuthenticationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<AuthenticationMiddleware> _logger;
    private readonly string[] _excludedPaths = { "/swagger", "/health", "/api/info", "/api/health", "/api/docs" };

    public AuthenticationMiddleware(RequestDelegate next, ILogger<AuthenticationMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, IAuthenticationService authService, IConfigurationService configService)
    {
        // Saltar validación para rutas públicas
        if (ShouldSkipValidation(context.Request.Path))
        {
            await _next(context);
            return;
        }

        try
        {
            // Extraer IdAPI de la query string
            if (!context.Request.Query.TryGetValue("idApi", out var idApiValue) || !int.TryParse(idApiValue, out var idAPI))
            {
                await WriteErrorResponse(context, HttpStatusCode.BadRequest, "IdAPI requerido");
                return;
            }

            // Obtener el tipo de autenticación requerido por la API
            var requiredAuthType = await authService.GetRequiredAuthTypeAsync(idAPI);

            if (string.IsNullOrEmpty(requiredAuthType))
            {
                await WriteErrorResponse(context, HttpStatusCode.NotFound, "API no encontrada");
                return;
            }

            // Si es API pública (NONE), permitir acceso sin autenticación
            if (requiredAuthType == "NONE")
            {
                await UpdateRequestContext(context, idAPI, null, "NONE");
                await _next(context);
                return;
            }

            // Extraer credencial del request
            var credential = ExtractCredential(context, requiredAuthType);
            if (string.IsNullOrEmpty(credential))
            {
                var authHeaderExample = GetAuthHeaderExample(requiredAuthType);
                await WriteErrorResponse(context, HttpStatusCode.Unauthorized,
                    $"Credencial requerida. Usar header: {authHeaderExample}");
                return;
            }

            // Crear request de validación
            var validationRequest = new CredentialValidationRequest
            {
                IdAPI = idAPI,
                TipoAuth = Enum.Parse<TipoAutenticacion>(requiredAuthType),
                Credential = credential,
                Environment = context.Request.Query["environment"].FirstOrDefault() ?? "PRODUCTION",
                Headers = ExtractHeaders(context),
                IPAddress = GetClientIpAddress(context)
            };

            // Validar autenticación
            var authResult = await authService.AuthenticateAsync(validationRequest);

            if (!authResult.IsValid)
            {
                // Log intento fallido
                await authService.LogAuthenticationAttemptAsync(idAPI, authResult.IdCredencial, false,
                    authResult.ErrorMessage, GetClientIpAddress(context));

                await WriteErrorResponse(context, HttpStatusCode.Unauthorized,
                    authResult.ErrorMessage ?? "Autenticación fallida");
                return;
            }

            if (authResult.RateLimitExceeded)
            {
                context.Response.Headers.Add("X-RateLimit-Remaining", "0");
                context.Response.Headers.Add("X-RateLimit-Reset",
                    authResult.ResetTime?.ToUnixTimeSeconds().ToString() ??
                    DateTimeOffset.UtcNow.AddMinutes(1).ToUnixTimeSeconds().ToString());

                await WriteErrorResponse(context, HttpStatusCode.TooManyRequests, "Rate limit excedido");
                return;
            }

            // Log intento exitoso
            await authService.LogAuthenticationAttemptAsync(idAPI, authResult.IdCredencial, true,
                null, GetClientIpAddress(context));

            // Actualizar contexto del request
            await UpdateRequestContext(context, idAPI, authResult.IdCredencial, authResult.TipoAuth, authResult);

            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error en middleware de autenticación");
            await WriteErrorResponse(context, HttpStatusCode.InternalServerError, "Error interno de autenticación");
        }
    }

    private bool ShouldSkipValidation(PathString path)
    {
        return _excludedPaths.Any(excluded => path.StartsWithSegments(excluded, StringComparison.OrdinalIgnoreCase));
    }

    private string? ExtractCredential(HttpContext context, string authType)
    {
        return authType switch
        {
            "TOKEN" => ExtractFromAuthorizationHeader(context, "Bearer") ?? ExtractFromCustomHeader(context, "X-API-Token"),
            "APIKEY" => ExtractFromCustomHeader(context, "X-API-Key") ?? ExtractFromAuthorizationHeader(context, "ApiKey"),
            "JWT" => ExtractFromAuthorizationHeader(context, "Bearer") ?? ExtractFromCustomHeader(context, "X-JWT-Token"),
            "OAUTH2" => ExtractFromAuthorizationHeader(context, "Bearer"),
            "NTLM" => ExtractFromAuthorizationHeader(context, "NTLM") ?? ExtractFromAuthorizationHeader(context, "Negotiate"),
            "BASIC" => ExtractFromAuthorizationHeader(context, "Basic"),
            _ => null
        };
    }

    private string? ExtractFromAuthorizationHeader(HttpContext context, string scheme)
    {
        var authHeader = context.Request.Headers.Authorization.FirstOrDefault();
        if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith($"{scheme} ", StringComparison.OrdinalIgnoreCase))
        {
            return authHeader[$"{scheme} ".Length..].Trim();
        }
        return null;
    }

    private string? ExtractFromCustomHeader(HttpContext context, string headerName)
    {
        return context.Request.Headers[headerName].FirstOrDefault();
    }

    private Dictionary<string, string> ExtractHeaders(HttpContext context)
    {
        var headers = new Dictionary<string, string>();

        foreach (var header in context.Request.Headers)
        {
            if (IsRelevantAuthHeader(header.Key))
            {
                headers[header.Key] = header.Value.ToString();
            }
        }

        return headers;
    }

    private bool IsRelevantAuthHeader(string headerName)
    {
        var relevantHeaders = new[] { "Authorization", "X-API-Token", "X-API-Key", "X-JWT-Token", "User-Agent", "X-Forwarded-For" };
        return relevantHeaders.Contains(headerName, StringComparer.OrdinalIgnoreCase);
    }

    private string GetAuthHeaderExample(string authType)
    {
        return authType switch
        {
            "TOKEN" => "Authorization: Bearer {token} o X-API-Token: {token}",
            "APIKEY" => "X-API-Key: {apikey} o Authorization: ApiKey {apikey}",
            "JWT" => "Authorization: Bearer {jwt}",
            "OAUTH2" => "Authorization: Bearer {oauth2_token}",
            "NTLM" => "Authorization: NTLM {ntlm_token}",
            "BASIC" => "Authorization: Basic {base64_credentials}",
            _ => "Ver documentación de la API"
        };
    }

    private async Task UpdateRequestContext(HttpContext context, int idAPI, int? idCredencial, string tipoAuth, AuthValidationResult? authResult = null)
    {
        if (context.Items["RequestContext"] is RequestContext requestContext)
        {
            requestContext.IdAPI = idAPI;
            requestContext.IdCredencial = idCredencial;
            requestContext.TipoAuth = tipoAuth;

            if (authResult?.AuthMetadata != null)
            {
                foreach (var metadata in authResult.AuthMetadata)
                {
                    requestContext.Metadata[metadata.Key] = metadata.Value;
                }
            }
        }
    }

    private string? GetClientIpAddress(HttpContext context)
    {
        return context.Request.Headers["X-Forwarded-For"].FirstOrDefault() ??
               context.Request.Headers["X-Real-IP"].FirstOrDefault() ??
               context.Connection.RemoteIpAddress?.ToString();
    }

    private async Task WriteErrorResponse(HttpContext context, HttpStatusCode statusCode, string message)
    {
        context.Response.StatusCode = (int)statusCode;
        context.Response.ContentType = "application/json";

        var requestId = context.Items["RequestContext"] is RequestContext ctx ? ctx.RequestId : Guid.NewGuid().ToString();

        var errorResponse = new ErrorResponse
        {
            Error = statusCode.ToString(),
            Message = message,
            StatusCode = (int)statusCode,
            RequestId = requestId,
            Timestamp = DateTime.UtcNow
        };

        var json = JsonSerializer.Serialize(errorResponse, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });

        await context.Response.WriteAsync(json);
    }
}// =====================================================
// ExceptionHandlingMiddleware - ACTUALIZADO
// =====================================================
using Microsoft.Data.SqlClient;
using System.Text.Json;

public class ExceptionHandlingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ExceptionHandlingMiddleware> _logger;
    private readonly IWebHostEnvironment _environment;

    public ExceptionHandlingMiddleware(RequestDelegate next, ILogger<ExceptionHandlingMiddleware> logger, IWebHostEnvironment environment)
    {
        _next = next;
        _logger = logger;
        _environment = environment;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        var requestContext = context.Items["RequestContext"] as RequestContext;
        var requestId = requestContext?.RequestId ?? Guid.NewGuid().ToString();

        // Log con informaci n de contexto de autenticaci n
        var logMessage = "Excepci n no manejada en request {RequestId}: {Message}";
        var logParams = new object[] { requestId, exception.Message };

        if (requestContext?.IdAPI.HasValue == true)
        {
            logMessage += " - API: {IdAPI}";
            logParams = logParams.Append(requestContext.IdAPI.Value).ToArray();

            if (!string.IsNullOrEmpty(requestContext.TipoAuth))
            {
                logMessage += " - Auth: {TipoAuth}";
                logParams = logParams.Append(requestContext.TipoAuth).ToArray();
            }
        }

        _logger.LogError(exception, logMessage, logParams);

        var statusCode = GetStatusCode(exception);
        var message = GetErrorMessage(exception);

        context.Response.StatusCode = statusCode;
        context.Response.ContentType = "application/json";

        var errorResponse = new ErrorResponse
        {
            Error = GetErrorType(exception),
            Message = message,
            StatusCode = statusCode,
            RequestId = requestId,
            Timestamp = DateTime.UtcNow
        };

        // En desarrollo, incluir stack trace
        if (_environment.IsDevelopment())
        {
            errorResponse.Message += $"\n\nStack Trace:\n{exception.StackTrace}";
        }

        var json = JsonSerializer.Serialize(errorResponse, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });

        await context.Response.WriteAsync(json);
    }

    private int GetStatusCode(Exception exception)
    {
        return exception switch
        {
            ArgumentException => 400,
            InvalidOperationException => 400,
            UnauthorizedAccessException => 401,
            NotSupportedException => 501,
            TimeoutException => 408,
            SqlException => 500,
            _ => 500
        };
    }

    private string GetErrorMessage(Exception exception)
    {
        return exception switch
        {
            ArgumentException => exception.Message,
            InvalidOperationException => exception.Message,
            UnauthorizedAccessException => "Acceso no autorizado",
            NotSupportedException => "Operaci n no soportada",
            TimeoutException => "Timeout en la operaci n",
            SqlException => "Error de base de datos",
            _ => _environment.IsDevelopment() ? exception.Message : "Error interno del servidor"
        };
    }

    private string GetErrorType(Exception exception)
    {
        return exception switch
        {
            ArgumentException => "INVALID_ARGUMENT",
            InvalidOperationException => "INVALID_OPERATION",
            UnauthorizedAccessException => "UNAUTHORIZED",
            NotSupportedException => "NOT_SUPPORTED",
            TimeoutException => "TIMEOUT",
            SqlException => "DATABASE_ERROR",
            _ => "INTERNAL_ERROR"
        };
    }
}
// =====================================================
// MetricsMiddleware - ACTUALIZADO
// =====================================================
using System.Diagnostics;

public class MetricsMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<MetricsMiddleware> _logger;

    public MetricsMiddleware(RequestDelegate next, ILogger<MetricsMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var stopwatch = Stopwatch.StartNew();

        await _next(context);

        stopwatch.Stop();

        // Log de m tricas con informaci n de autenticaci n
        if (context.Items["RequestContext"] is RequestContext requestContext && requestContext.IdAPI.HasValue)
        {
            _logger.LogInformation("API Execution Metrics: IdAPI={IdAPI}, Duration={DurationMs}, Status={StatusCode}, Success={Success}, Auth={TipoAuth}, Credencial={IdCredencial}",
                requestContext.IdAPI.Value,
                stopwatch.ElapsedMilliseconds,
                context.Response.StatusCode,
                context.Response.StatusCode >= 200 && context.Response.StatusCode < 400,
                requestContext.TipoAuth ?? "NONE",
                requestContext.IdCredencial);
        }
    }
}using System.Diagnostics;

// =====================================================
// RequestLoggingMiddleware - ACTUALIZADO
// =====================================================
public class RequestLoggingMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<RequestLoggingMiddleware> _logger;

    public RequestLoggingMiddleware(RequestDelegate next, ILogger<RequestLoggingMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        var requestId = Guid.NewGuid().ToString();
        var stopwatch = Stopwatch.StartNew();

        // Agregar informaci n al contexto
        var requestContext = new RequestContext
        {
            RequestId = requestId,
            StartTime = DateTime.UtcNow,
            ClientIP = GetClientIpAddress(context),
            Environment = context.Request.Query["environment"].FirstOrDefault() ?? "PRODUCTION"
        };

        context.Items["RequestContext"] = requestContext;
        context.Response.Headers.Add("X-Request-ID", requestId);

        // Log del request inicial
        _logger.LogInformation("Request started: {RequestId} {Method} {Path} from {ClientIP}",
            requestId, context.Request.Method, context.Request.Path, requestContext.ClientIP);

        try
        {
            await _next(context);
        }
        finally
        {
            stopwatch.Stop();

            // Log enriquecido con informaci n de autenticaci n
            var logMessage = "Request completed: {RequestId} {StatusCode} in {ElapsedMs}ms";
            var logParams = new object[] { requestId, context.Response.StatusCode, stopwatch.ElapsedMilliseconds };

            if (requestContext.IdAPI.HasValue)
            {
                logMessage += " - API: {IdAPI}";
                logParams = logParams.Append(requestContext.IdAPI.Value).ToArray();

                if (requestContext.IdCredencial.HasValue)
                {
                    logMessage += " - Credencial: {IdCredencial}";
                    logParams = logParams.Append(requestContext.IdCredencial.Value).ToArray();
                }

                if (!string.IsNullOrEmpty(requestContext.TipoAuth))
                {
                    logMessage += " - Auth: {TipoAuth}";
                    logParams = logParams.Append(requestContext.TipoAuth).ToArray();
                }
            }

            _logger.LogInformation(logMessage, logParams);
        }
    }

    private string? GetClientIpAddress(HttpContext context)
    {
        return context.Request.Headers["X-Forwarded-For"].FirstOrDefault() ??
               context.Request.Headers["X-Real-IP"].FirstOrDefault() ??
               context.Connection.RemoteIpAddress?.ToString();
    }
}// Middleware para validaci n de tokens
using System.Net;
using System.Text.Json;

public class TokenValidationMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<TokenValidationMiddleware> _logger;
    private readonly string[] _excludedPaths = { "/swagger", "/health", "/api/info", "/api/health" };

    public TokenValidationMiddleware(RequestDelegate next, ILogger<TokenValidationMiddleware> logger)
    {
        _next = next;
        _logger = logger;
    }

    public async Task InvokeAsync(HttpContext context, ITokenValidationService tokenService)
    {
        // Saltar validaci n para rutas p blicas
        if (ShouldSkipValidation(context.Request.Path))
        {
            await _next(context);
            return;
        }

        var token = ExtractToken(context);
        if (string.IsNullOrEmpty(token))
        {
            await WriteErrorResponse(context, HttpStatusCode.Unauthorized, "Token requerido");
            return;
        }

        try
        {
            var validationResult = await tokenService.ValidateTokenAsync(token);

            if (!validationResult.IsValid)
            {
                await WriteErrorResponse(context, HttpStatusCode.Unauthorized,
                    validationResult.ErrorMessage ?? "Token inv lido");
                return;
            }

            if (validationResult.RateLimitExceeded)
            {
                context.Response.Headers.Add("X-RateLimit-Remaining", "0");
                context.Response.Headers.Add("X-RateLimit-Reset", DateTimeOffset.UtcNow.AddMinutes(1).ToUnixTimeSeconds().ToString());

                await WriteErrorResponse(context, HttpStatusCode.TooManyRequests, "Rate limit excedido");
                return;
            }

            // Agregar informaci n del token al contexto
            if (context.Items["RequestContext"] is RequestContext requestContext)
            {
                requestContext.Token = token;
                requestContext.IdAPI = validationResult.IdAPI;
                requestContext.IdToken = validationResult.IdToken;
            }

            await _next(context);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error validando token");
            await WriteErrorResponse(context, HttpStatusCode.InternalServerError, "Error interno validando token");
        }
    }

    private bool ShouldSkipValidation(PathString path)
    {
        return _excludedPaths.Any(excluded => path.StartsWithSegments(excluded, StringComparison.OrdinalIgnoreCase));
    }

    private string? ExtractToken(HttpContext context)
    {
        // Buscar en header Authorization (Bearer token)
        var authHeader = context.Request.Headers.Authorization.FirstOrDefault();
        if (!string.IsNullOrEmpty(authHeader) && authHeader.StartsWith("Bearer ", StringComparison.OrdinalIgnoreCase))
        {
            return authHeader["Bearer ".Length..].Trim();
        }

        // Buscar en header X-API-Token
        return context.Request.Headers["X-API-Token"].FirstOrDefault();
    }

    private async Task WriteErrorResponse(HttpContext context, HttpStatusCode statusCode, string message)
    {
        context.Response.StatusCode = (int)statusCode;
        context.Response.ContentType = "application/json";

        var requestId = context.Items["RequestContext"] is RequestContext ctx ? ctx.RequestId : Guid.NewGuid().ToString();

        var errorResponse = new ErrorResponse
        {
            Error = statusCode.ToString(),
            Message = message,
            StatusCode = (int)statusCode,
            RequestId = requestId
        };

        var json = JsonSerializer.Serialize(errorResponse, new JsonSerializerOptions
        {
            PropertyNamingPolicy = JsonNamingPolicy.CamelCase
        });

        await context.Response.WriteAsync(json);
    }
}